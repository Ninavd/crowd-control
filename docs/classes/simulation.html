<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>crowd-control.classes.simulation API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>crowd-control.classes.simulation</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import copy
import matplotlib.pyplot as plt 
import numpy as np 
import random 

from numpy import ndarray
from collections import defaultdict
from classes.lattice import Lattice
from classes.cell import Cell
from helpers import get_value_array


class Simulation:

    &#34;&#34;&#34;
    Simulates heterogenous crowd in an infinite corridor.

    Attributes:
        N (int): Total number of people in the corridor.
        iters (int): Number of iterations (timesteps) to execute.
        corridor (Lattice): Object representing the initial state of populated corridor.
        populated_cells (ndarray[Cell]): Array of currently populated cell objects .
        p (float): probability of agents moving straight (soberness).
    &#34;&#34;&#34;

    def __init__(self, iters, corridor, p=1):
        &#34;&#34;&#34;
        Initializes the simulation object.

        Args:
            N (int): Total number of people in the corridor.
            iters (int): Number of iterations (timesteps) to exectue
            corridor (Lattice): Object representing the initial state of populated corridor.
            p (float): probability of agents moving straight (soberness).
        &#34;&#34;&#34;
        self.N = len(corridor.get_populated_cells())
        self.iters = iters
        self.corridor: Lattice = copy.deepcopy(corridor)
        self.corridor.load_neighbours()
        self.populated_cells: ndarray[Cell] = self.corridor.get_populated_cells()
        self.p = p

    def find_target_cell(self, cell: Cell) -&gt; Cell | None:
        &#34;&#34;&#34;
        Find and return target cell while considering boundary conditions.
        Implicitly returns None if no target cell available.

        Args:
            cell (Cell): Populated cell that needs to target next cell.
        &#34;&#34;&#34;
        assert cell.value != 0, &#39;Unpopulated cell should not target a cell&#39;

        # check periodic boundary conditions
        if cell.is_leaving_left():
            new_y = self.corridor.len_y - 1
            return self.corridor.get_random_empty_edge_cell(new_y, x=cell.x, p=self.p)
        elif cell.is_leaving_right(self.corridor.len_y):
            return self.corridor.get_random_empty_edge_cell(y=0, x=cell.x, p=self.p)
        
        # cell is not a boundary cell
        return cell.get_best_neighbor(self.p)

    def resolve_conflicts(self, next_cells):
        &#34;&#34;&#34;
        Resolve conflicts in the next_cells dictionary.
        If cell targeted by multiple cells, random cell wins and others stay put.
        Return dict with coordinate of target cell as key, cell object as value.

        Args:
            next_cells: dict with coordinate of target cell as keys, list of cells as values.
        &#34;&#34;&#34;
        targets = list(next_cells.keys())
        cell_assigned = {}

        for target in targets:
            candidates = next_cells[target]

            if len(candidates) == 1:
                cell_assigned[target] = candidates[0]
            else:
                for _ in range(len(candidates) - 1):
                    loser = candidates.pop(random.randint(0, len(candidates) - 1))
                    cell_assigned[(loser.x, loser.y)] = loser
                winner = candidates[0]
                cell_assigned[target] = winner
        
        return cell_assigned
    
    def execute_timestep(self, next_cells):
        &#34;&#34;&#34;
        Populate new cells and empty old ones.
        Adjust distance value of visited cells. 

        Args:
            next_cells (dict): Defines all moves to execute.
        &#34;&#34;&#34;
        for new_cell_coords, old_cell in next_cells.items():
            value = old_cell.value
            new_cell = self.corridor.cells[new_cell_coords]
            
            if old_cell != new_cell: 
                old_cell.lower_distance_to_exit()
            
            old_cell.clear()    
            new_cell.populate(value)

    def iteration(self):
        &#34;&#34;&#34;
        Execute one iteration of the Cellular Automata.
        &#34;&#34;&#34;
        # key=tuple with coords of a targeted cell, value=list of old_cell(s)
        next_cells = defaultdict(list) 
 
        for cell in self.populated_cells:
            
            target_cell = self.find_target_cell(cell)
            
            # save targeted cells
            if target_cell: 
                next_cells[(target_cell.x, target_cell.y)].append(cell)
            else:
                next_cells[((cell.x, cell.y))] = [cell] 
        
        # solve conflicts when cell is targeted by multiple cells
        next_cells = self.resolve_conflicts(next_cells)

        # populate new cells and empty old ones
        self.execute_timestep(next_cells)
        
        # update populated cells
        self.populated_cells = self.corridor.get_populated_cells()

    def run(self, animate=True, save_video=True, print_progress=True):
        &#34;&#34;&#34;
        Execute self.iters iterations and return evolution of order parameter.

        Args:
            animate (bool): Animates progress if true.
            save_video (bool): Saves CA snapshots if true
            print_progress (bool): Prints iteration number if true.
        &#34;&#34;&#34;
        images = []
        if animate:
            plt.figure(figsize=(12, 5))
            plt.ion()
            
        phi_0 = calculate_phi_0(self.corridor.len_x, self.corridor.len_y, self.N)
        print(f&#39;phi_0:{phi_0:.3f}&#39;)
        phi_values = np.zeros(self.iters)
        
        for i in range(self.iters):
            print(f&#39;iteration {i+1}/{self.iters}     &#39;, end=&#39;\r&#39;) if print_progress else None
            
            # update all cells
            self.iteration()
            
            # update order parameter
            phi = self.corridor.calculate_lane_formation()
            phi_reduced = (phi-phi_0)/(1-phi_0)
            phi_values[i] = phi_reduced

            if save_video == True:
                images.append(get_value_array(self.corridor.cells))

            self.animate(i, phi_values) if animate else None   

        plt.ioff() if animate else None

        assert len(self.corridor.get_populated_cells()) == self.N, &#39;Density has changed during simulation&#39;
        return images, phi_values
    
    def animate(self, i, phi_values):
        &#34;&#34;&#34;
        Animates one frame of the simulation. 

        Args:
            i (int): Current iteration number.
            phi_values (list[float]): array of phi value per iteration.
        &#34;&#34;&#34;
        # plot lattice
        plt.subplot(1,2,1)
        self.plot_snapshot(colorbar=False)

        # plot phi evolution
        plt.subplot(1,2,2)
        plt.xlabel(&#39;iteration&#39;)
        plt.ylabel(&#39;$\\tilde{\phi}$&#39;, fontsize=14)
        plt.plot(list(range(i + 1)), phi_values[0:i+1], &#39;k-&#39;)
        plt.pause(0.005)
        plt.clf()

    def plot_snapshot(self, colorbar=True):
        &#34;&#34;&#34;
        Plots snapshot of the current state of the lattice.
        &#34;&#34;&#34;
        plt.imshow(get_value_array(self.corridor.cells), interpolation=&#34;nearest&#34;, origin=&#34;upper&#34;)
        plt.colorbar() if colorbar == True else None
        plt.show()
    
    def plot_results(self, phi_values, save=False):
        &#34;&#34;&#34;
        Plots final configuration of the lattice and progress of phi in one figure.
        &#34;&#34;&#34;
        plt.figure(figsize=(12, 5))
        plt.subplot(121)
        plt.imshow(get_value_array(self.corridor.cells), interpolation=&#34;nearest&#34;, origin=&#34;upper&#34;)
        plt.colorbar() 

        plt.subplot(122)
        plt.xlabel(&#39;iteration&#39;)
        plt.ylabel(&#39;$\\tilde{\phi}$&#39;, fontsize=14)
        plt.plot(list(range(len(phi_values))), phi_values, &#39;k-&#39;)

        if save:
            density = self.N / (self.corridor.len_x * self.corridor.len_y)
            plt.savefig(f&#39;./results/final_snapshots/L_{self.corridor.len_x}_rho_{density}_p_{self.p}.png&#39;)

def calculate_phi_0(len_x, len_y, N):
    &#34;&#34;&#34;
    Calculates phi_0, the normalization factor for the reduced order parameter
    (measures the degree of lane formation) by generating 100 random corridors.

    Args:
        len_x (int): Number of rows of the corridor.
        len_y (int): Number of columns of the corridor.
        N (int): Number of agents in the corridor.
    &#34;&#34;&#34;
    phi_randoms = np.zeros(100)
    for j in range(0,100):
        corridor = Lattice(len_x, len_y)
        corridor.populate_corridor(N)
        phi_randoms[j] = corridor.calculate_lane_formation()
    phi_0 = np.mean(phi_randoms)
    return phi_0</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="crowd-control.classes.simulation.calculate_phi_0"><code class="name flex">
<span>def <span class="ident">calculate_phi_0</span></span>(<span>len_x, len_y, N)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates phi_0, the normalization factor for the reduced order parameter
(measures the degree of lane formation) by generating 100 random corridors.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>len_x</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of rows of the corridor.</dd>
<dt><strong><code>len_y</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of columns of the corridor.</dd>
<dt><strong><code>N</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of agents in the corridor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_phi_0(len_x, len_y, N):
    &#34;&#34;&#34;
    Calculates phi_0, the normalization factor for the reduced order parameter
    (measures the degree of lane formation) by generating 100 random corridors.

    Args:
        len_x (int): Number of rows of the corridor.
        len_y (int): Number of columns of the corridor.
        N (int): Number of agents in the corridor.
    &#34;&#34;&#34;
    phi_randoms = np.zeros(100)
    for j in range(0,100):
        corridor = Lattice(len_x, len_y)
        corridor.populate_corridor(N)
        phi_randoms[j] = corridor.calculate_lane_formation()
    phi_0 = np.mean(phi_randoms)
    return phi_0</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="crowd-control.classes.simulation.Simulation"><code class="flex name class">
<span>class <span class="ident">Simulation</span></span>
<span>(</span><span>iters, corridor, p=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulates heterogenous crowd in an infinite corridor.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>N</code></strong> :&ensp;<code>int</code></dt>
<dd>Total number of people in the corridor.</dd>
<dt><strong><code>iters</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of iterations (timesteps) to execute.</dd>
<dt><strong><code>corridor</code></strong> :&ensp;<code>Lattice</code></dt>
<dd>Object representing the initial state of populated corridor.</dd>
<dt><strong><code>populated_cells</code></strong> :&ensp;<code>ndarray[Cell]</code></dt>
<dd>Array of currently populated cell objects .</dd>
<dt><strong><code>p</code></strong> :&ensp;<code>float</code></dt>
<dd>probability of agents moving straight (soberness).</dd>
</dl>
<p>Initializes the simulation object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>N</code></strong> :&ensp;<code>int</code></dt>
<dd>Total number of people in the corridor.</dd>
<dt><strong><code>iters</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of iterations (timesteps) to exectue</dd>
<dt><strong><code>corridor</code></strong> :&ensp;<code>Lattice</code></dt>
<dd>Object representing the initial state of populated corridor.</dd>
<dt><strong><code>p</code></strong> :&ensp;<code>float</code></dt>
<dd>probability of agents moving straight (soberness).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Simulation:

    &#34;&#34;&#34;
    Simulates heterogenous crowd in an infinite corridor.

    Attributes:
        N (int): Total number of people in the corridor.
        iters (int): Number of iterations (timesteps) to execute.
        corridor (Lattice): Object representing the initial state of populated corridor.
        populated_cells (ndarray[Cell]): Array of currently populated cell objects .
        p (float): probability of agents moving straight (soberness).
    &#34;&#34;&#34;

    def __init__(self, iters, corridor, p=1):
        &#34;&#34;&#34;
        Initializes the simulation object.

        Args:
            N (int): Total number of people in the corridor.
            iters (int): Number of iterations (timesteps) to exectue
            corridor (Lattice): Object representing the initial state of populated corridor.
            p (float): probability of agents moving straight (soberness).
        &#34;&#34;&#34;
        self.N = len(corridor.get_populated_cells())
        self.iters = iters
        self.corridor: Lattice = copy.deepcopy(corridor)
        self.corridor.load_neighbours()
        self.populated_cells: ndarray[Cell] = self.corridor.get_populated_cells()
        self.p = p

    def find_target_cell(self, cell: Cell) -&gt; Cell | None:
        &#34;&#34;&#34;
        Find and return target cell while considering boundary conditions.
        Implicitly returns None if no target cell available.

        Args:
            cell (Cell): Populated cell that needs to target next cell.
        &#34;&#34;&#34;
        assert cell.value != 0, &#39;Unpopulated cell should not target a cell&#39;

        # check periodic boundary conditions
        if cell.is_leaving_left():
            new_y = self.corridor.len_y - 1
            return self.corridor.get_random_empty_edge_cell(new_y, x=cell.x, p=self.p)
        elif cell.is_leaving_right(self.corridor.len_y):
            return self.corridor.get_random_empty_edge_cell(y=0, x=cell.x, p=self.p)
        
        # cell is not a boundary cell
        return cell.get_best_neighbor(self.p)

    def resolve_conflicts(self, next_cells):
        &#34;&#34;&#34;
        Resolve conflicts in the next_cells dictionary.
        If cell targeted by multiple cells, random cell wins and others stay put.
        Return dict with coordinate of target cell as key, cell object as value.

        Args:
            next_cells: dict with coordinate of target cell as keys, list of cells as values.
        &#34;&#34;&#34;
        targets = list(next_cells.keys())
        cell_assigned = {}

        for target in targets:
            candidates = next_cells[target]

            if len(candidates) == 1:
                cell_assigned[target] = candidates[0]
            else:
                for _ in range(len(candidates) - 1):
                    loser = candidates.pop(random.randint(0, len(candidates) - 1))
                    cell_assigned[(loser.x, loser.y)] = loser
                winner = candidates[0]
                cell_assigned[target] = winner
        
        return cell_assigned
    
    def execute_timestep(self, next_cells):
        &#34;&#34;&#34;
        Populate new cells and empty old ones.
        Adjust distance value of visited cells. 

        Args:
            next_cells (dict): Defines all moves to execute.
        &#34;&#34;&#34;
        for new_cell_coords, old_cell in next_cells.items():
            value = old_cell.value
            new_cell = self.corridor.cells[new_cell_coords]
            
            if old_cell != new_cell: 
                old_cell.lower_distance_to_exit()
            
            old_cell.clear()    
            new_cell.populate(value)

    def iteration(self):
        &#34;&#34;&#34;
        Execute one iteration of the Cellular Automata.
        &#34;&#34;&#34;
        # key=tuple with coords of a targeted cell, value=list of old_cell(s)
        next_cells = defaultdict(list) 
 
        for cell in self.populated_cells:
            
            target_cell = self.find_target_cell(cell)
            
            # save targeted cells
            if target_cell: 
                next_cells[(target_cell.x, target_cell.y)].append(cell)
            else:
                next_cells[((cell.x, cell.y))] = [cell] 
        
        # solve conflicts when cell is targeted by multiple cells
        next_cells = self.resolve_conflicts(next_cells)

        # populate new cells and empty old ones
        self.execute_timestep(next_cells)
        
        # update populated cells
        self.populated_cells = self.corridor.get_populated_cells()

    def run(self, animate=True, save_video=True, print_progress=True):
        &#34;&#34;&#34;
        Execute self.iters iterations and return evolution of order parameter.

        Args:
            animate (bool): Animates progress if true.
            save_video (bool): Saves CA snapshots if true
            print_progress (bool): Prints iteration number if true.
        &#34;&#34;&#34;
        images = []
        if animate:
            plt.figure(figsize=(12, 5))
            plt.ion()
            
        phi_0 = calculate_phi_0(self.corridor.len_x, self.corridor.len_y, self.N)
        print(f&#39;phi_0:{phi_0:.3f}&#39;)
        phi_values = np.zeros(self.iters)
        
        for i in range(self.iters):
            print(f&#39;iteration {i+1}/{self.iters}     &#39;, end=&#39;\r&#39;) if print_progress else None
            
            # update all cells
            self.iteration()
            
            # update order parameter
            phi = self.corridor.calculate_lane_formation()
            phi_reduced = (phi-phi_0)/(1-phi_0)
            phi_values[i] = phi_reduced

            if save_video == True:
                images.append(get_value_array(self.corridor.cells))

            self.animate(i, phi_values) if animate else None   

        plt.ioff() if animate else None

        assert len(self.corridor.get_populated_cells()) == self.N, &#39;Density has changed during simulation&#39;
        return images, phi_values
    
    def animate(self, i, phi_values):
        &#34;&#34;&#34;
        Animates one frame of the simulation. 

        Args:
            i (int): Current iteration number.
            phi_values (list[float]): array of phi value per iteration.
        &#34;&#34;&#34;
        # plot lattice
        plt.subplot(1,2,1)
        self.plot_snapshot(colorbar=False)

        # plot phi evolution
        plt.subplot(1,2,2)
        plt.xlabel(&#39;iteration&#39;)
        plt.ylabel(&#39;$\\tilde{\phi}$&#39;, fontsize=14)
        plt.plot(list(range(i + 1)), phi_values[0:i+1], &#39;k-&#39;)
        plt.pause(0.005)
        plt.clf()

    def plot_snapshot(self, colorbar=True):
        &#34;&#34;&#34;
        Plots snapshot of the current state of the lattice.
        &#34;&#34;&#34;
        plt.imshow(get_value_array(self.corridor.cells), interpolation=&#34;nearest&#34;, origin=&#34;upper&#34;)
        plt.colorbar() if colorbar == True else None
        plt.show()
    
    def plot_results(self, phi_values, save=False):
        &#34;&#34;&#34;
        Plots final configuration of the lattice and progress of phi in one figure.
        &#34;&#34;&#34;
        plt.figure(figsize=(12, 5))
        plt.subplot(121)
        plt.imshow(get_value_array(self.corridor.cells), interpolation=&#34;nearest&#34;, origin=&#34;upper&#34;)
        plt.colorbar() 

        plt.subplot(122)
        plt.xlabel(&#39;iteration&#39;)
        plt.ylabel(&#39;$\\tilde{\phi}$&#39;, fontsize=14)
        plt.plot(list(range(len(phi_values))), phi_values, &#39;k-&#39;)

        if save:
            density = self.N / (self.corridor.len_x * self.corridor.len_y)
            plt.savefig(f&#39;./results/final_snapshots/L_{self.corridor.len_x}_rho_{density}_p_{self.p}.png&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="crowd-control.classes.simulation.Simulation.animate"><code class="name flex">
<span>def <span class="ident">animate</span></span>(<span>self, i, phi_values)</span>
</code></dt>
<dd>
<div class="desc"><p>Animates one frame of the simulation. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>i</code></strong> :&ensp;<code>int</code></dt>
<dd>Current iteration number.</dd>
<dt><strong><code>phi_values</code></strong> :&ensp;<code>list[float]</code></dt>
<dd>array of phi value per iteration.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def animate(self, i, phi_values):
    &#34;&#34;&#34;
    Animates one frame of the simulation. 

    Args:
        i (int): Current iteration number.
        phi_values (list[float]): array of phi value per iteration.
    &#34;&#34;&#34;
    # plot lattice
    plt.subplot(1,2,1)
    self.plot_snapshot(colorbar=False)

    # plot phi evolution
    plt.subplot(1,2,2)
    plt.xlabel(&#39;iteration&#39;)
    plt.ylabel(&#39;$\\tilde{\phi}$&#39;, fontsize=14)
    plt.plot(list(range(i + 1)), phi_values[0:i+1], &#39;k-&#39;)
    plt.pause(0.005)
    plt.clf()</code></pre>
</details>
</dd>
<dt id="crowd-control.classes.simulation.Simulation.execute_timestep"><code class="name flex">
<span>def <span class="ident">execute_timestep</span></span>(<span>self, next_cells)</span>
</code></dt>
<dd>
<div class="desc"><p>Populate new cells and empty old ones.
Adjust distance value of visited cells. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>next_cells</code></strong> :&ensp;<code>dict</code></dt>
<dd>Defines all moves to execute.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute_timestep(self, next_cells):
    &#34;&#34;&#34;
    Populate new cells and empty old ones.
    Adjust distance value of visited cells. 

    Args:
        next_cells (dict): Defines all moves to execute.
    &#34;&#34;&#34;
    for new_cell_coords, old_cell in next_cells.items():
        value = old_cell.value
        new_cell = self.corridor.cells[new_cell_coords]
        
        if old_cell != new_cell: 
            old_cell.lower_distance_to_exit()
        
        old_cell.clear()    
        new_cell.populate(value)</code></pre>
</details>
</dd>
<dt id="crowd-control.classes.simulation.Simulation.find_target_cell"><code class="name flex">
<span>def <span class="ident">find_target_cell</span></span>(<span>self, cell: classes.cell.Cell) ‑> classes.cell.Cell | None</span>
</code></dt>
<dd>
<div class="desc"><p>Find and return target cell while considering boundary conditions.
Implicitly returns None if no target cell available.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cell</code></strong> :&ensp;<code>Cell</code></dt>
<dd>Populated cell that needs to target next cell.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_target_cell(self, cell: Cell) -&gt; Cell | None:
    &#34;&#34;&#34;
    Find and return target cell while considering boundary conditions.
    Implicitly returns None if no target cell available.

    Args:
        cell (Cell): Populated cell that needs to target next cell.
    &#34;&#34;&#34;
    assert cell.value != 0, &#39;Unpopulated cell should not target a cell&#39;

    # check periodic boundary conditions
    if cell.is_leaving_left():
        new_y = self.corridor.len_y - 1
        return self.corridor.get_random_empty_edge_cell(new_y, x=cell.x, p=self.p)
    elif cell.is_leaving_right(self.corridor.len_y):
        return self.corridor.get_random_empty_edge_cell(y=0, x=cell.x, p=self.p)
    
    # cell is not a boundary cell
    return cell.get_best_neighbor(self.p)</code></pre>
</details>
</dd>
<dt id="crowd-control.classes.simulation.Simulation.iteration"><code class="name flex">
<span>def <span class="ident">iteration</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Execute one iteration of the Cellular Automata.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iteration(self):
    &#34;&#34;&#34;
    Execute one iteration of the Cellular Automata.
    &#34;&#34;&#34;
    # key=tuple with coords of a targeted cell, value=list of old_cell(s)
    next_cells = defaultdict(list) 

    for cell in self.populated_cells:
        
        target_cell = self.find_target_cell(cell)
        
        # save targeted cells
        if target_cell: 
            next_cells[(target_cell.x, target_cell.y)].append(cell)
        else:
            next_cells[((cell.x, cell.y))] = [cell] 
    
    # solve conflicts when cell is targeted by multiple cells
    next_cells = self.resolve_conflicts(next_cells)

    # populate new cells and empty old ones
    self.execute_timestep(next_cells)
    
    # update populated cells
    self.populated_cells = self.corridor.get_populated_cells()</code></pre>
</details>
</dd>
<dt id="crowd-control.classes.simulation.Simulation.plot_results"><code class="name flex">
<span>def <span class="ident">plot_results</span></span>(<span>self, phi_values, save=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots final configuration of the lattice and progress of phi in one figure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_results(self, phi_values, save=False):
    &#34;&#34;&#34;
    Plots final configuration of the lattice and progress of phi in one figure.
    &#34;&#34;&#34;
    plt.figure(figsize=(12, 5))
    plt.subplot(121)
    plt.imshow(get_value_array(self.corridor.cells), interpolation=&#34;nearest&#34;, origin=&#34;upper&#34;)
    plt.colorbar() 

    plt.subplot(122)
    plt.xlabel(&#39;iteration&#39;)
    plt.ylabel(&#39;$\\tilde{\phi}$&#39;, fontsize=14)
    plt.plot(list(range(len(phi_values))), phi_values, &#39;k-&#39;)

    if save:
        density = self.N / (self.corridor.len_x * self.corridor.len_y)
        plt.savefig(f&#39;./results/final_snapshots/L_{self.corridor.len_x}_rho_{density}_p_{self.p}.png&#39;)</code></pre>
</details>
</dd>
<dt id="crowd-control.classes.simulation.Simulation.plot_snapshot"><code class="name flex">
<span>def <span class="ident">plot_snapshot</span></span>(<span>self, colorbar=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots snapshot of the current state of the lattice.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_snapshot(self, colorbar=True):
    &#34;&#34;&#34;
    Plots snapshot of the current state of the lattice.
    &#34;&#34;&#34;
    plt.imshow(get_value_array(self.corridor.cells), interpolation=&#34;nearest&#34;, origin=&#34;upper&#34;)
    plt.colorbar() if colorbar == True else None
    plt.show()</code></pre>
</details>
</dd>
<dt id="crowd-control.classes.simulation.Simulation.resolve_conflicts"><code class="name flex">
<span>def <span class="ident">resolve_conflicts</span></span>(<span>self, next_cells)</span>
</code></dt>
<dd>
<div class="desc"><p>Resolve conflicts in the next_cells dictionary.
If cell targeted by multiple cells, random cell wins and others stay put.
Return dict with coordinate of target cell as key, cell object as value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>next_cells</code></strong></dt>
<dd>dict with coordinate of target cell as keys, list of cells as values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve_conflicts(self, next_cells):
    &#34;&#34;&#34;
    Resolve conflicts in the next_cells dictionary.
    If cell targeted by multiple cells, random cell wins and others stay put.
    Return dict with coordinate of target cell as key, cell object as value.

    Args:
        next_cells: dict with coordinate of target cell as keys, list of cells as values.
    &#34;&#34;&#34;
    targets = list(next_cells.keys())
    cell_assigned = {}

    for target in targets:
        candidates = next_cells[target]

        if len(candidates) == 1:
            cell_assigned[target] = candidates[0]
        else:
            for _ in range(len(candidates) - 1):
                loser = candidates.pop(random.randint(0, len(candidates) - 1))
                cell_assigned[(loser.x, loser.y)] = loser
            winner = candidates[0]
            cell_assigned[target] = winner
    
    return cell_assigned</code></pre>
</details>
</dd>
<dt id="crowd-control.classes.simulation.Simulation.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, animate=True, save_video=True, print_progress=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Execute self.iters iterations and return evolution of order parameter.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>animate</code></strong> :&ensp;<code>bool</code></dt>
<dd>Animates progress if true.</dd>
<dt><strong><code>save_video</code></strong> :&ensp;<code>bool</code></dt>
<dd>Saves CA snapshots if true</dd>
<dt><strong><code>print_progress</code></strong> :&ensp;<code>bool</code></dt>
<dd>Prints iteration number if true.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, animate=True, save_video=True, print_progress=True):
    &#34;&#34;&#34;
    Execute self.iters iterations and return evolution of order parameter.

    Args:
        animate (bool): Animates progress if true.
        save_video (bool): Saves CA snapshots if true
        print_progress (bool): Prints iteration number if true.
    &#34;&#34;&#34;
    images = []
    if animate:
        plt.figure(figsize=(12, 5))
        plt.ion()
        
    phi_0 = calculate_phi_0(self.corridor.len_x, self.corridor.len_y, self.N)
    print(f&#39;phi_0:{phi_0:.3f}&#39;)
    phi_values = np.zeros(self.iters)
    
    for i in range(self.iters):
        print(f&#39;iteration {i+1}/{self.iters}     &#39;, end=&#39;\r&#39;) if print_progress else None
        
        # update all cells
        self.iteration()
        
        # update order parameter
        phi = self.corridor.calculate_lane_formation()
        phi_reduced = (phi-phi_0)/(1-phi_0)
        phi_values[i] = phi_reduced

        if save_video == True:
            images.append(get_value_array(self.corridor.cells))

        self.animate(i, phi_values) if animate else None   

    plt.ioff() if animate else None

    assert len(self.corridor.get_populated_cells()) == self.N, &#39;Density has changed during simulation&#39;
    return images, phi_values</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="crowd-control.classes" href="index.html">crowd-control.classes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="crowd-control.classes.simulation.calculate_phi_0" href="#crowd-control.classes.simulation.calculate_phi_0">calculate_phi_0</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="crowd-control.classes.simulation.Simulation" href="#crowd-control.classes.simulation.Simulation">Simulation</a></code></h4>
<ul class="two-column">
<li><code><a title="crowd-control.classes.simulation.Simulation.animate" href="#crowd-control.classes.simulation.Simulation.animate">animate</a></code></li>
<li><code><a title="crowd-control.classes.simulation.Simulation.execute_timestep" href="#crowd-control.classes.simulation.Simulation.execute_timestep">execute_timestep</a></code></li>
<li><code><a title="crowd-control.classes.simulation.Simulation.find_target_cell" href="#crowd-control.classes.simulation.Simulation.find_target_cell">find_target_cell</a></code></li>
<li><code><a title="crowd-control.classes.simulation.Simulation.iteration" href="#crowd-control.classes.simulation.Simulation.iteration">iteration</a></code></li>
<li><code><a title="crowd-control.classes.simulation.Simulation.plot_results" href="#crowd-control.classes.simulation.Simulation.plot_results">plot_results</a></code></li>
<li><code><a title="crowd-control.classes.simulation.Simulation.plot_snapshot" href="#crowd-control.classes.simulation.Simulation.plot_snapshot">plot_snapshot</a></code></li>
<li><code><a title="crowd-control.classes.simulation.Simulation.resolve_conflicts" href="#crowd-control.classes.simulation.Simulation.resolve_conflicts">resolve_conflicts</a></code></li>
<li><code><a title="crowd-control.classes.simulation.Simulation.run" href="#crowd-control.classes.simulation.Simulation.run">run</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>